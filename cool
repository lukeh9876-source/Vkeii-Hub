local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Vkeii Hub",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Vkeii Hub",
   LoadingSubtitle = "by reelslicedz on discord",
   ShowText = "Rayfield", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Vkeii Hub", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "Z", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Stinky Key System",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Vkeii Hub Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"https://pastebin.com/raw/0zx5bFCk"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = Window:CreateTab("Home", nil) -- Title, Image
local Section = MainTab:CreateSection("Aimbot")
 
    getgenv().CamLock = false
    getgenv().Smoothness = 0.5
    getgenv().MaxLockDistance = 100
    getgenv().FOVRadius = 200
 
    local function GetClosestPlayer()
        local plr = game.Players.LocalPlayer
        local char = plr.Character
        if not char then return nil end
        local hrp = char.HumanoidRootPart
        local cam = workspace.CurrentCamera
        local closest = nil
        local minDist = math.huge
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= plr and p.Character and p.Character:FindFirstChild("Head") then
                local head = p.Character.Head
                local charPos = p.Character.HumanoidRootPart.Position
                local dist3d = (hrp.Position - charPos).Magnitude
                if dist3d > getgenv().MaxLockDistance then continue end
                local screenPos, onScreen = cam:WorldToViewportPoint(head.Position)
                if onScreen then
                    local center = cam.ViewportSize / 2
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                    if screenDist < getgenv().FOVRadius and screenDist < minDist then
                        minDist = screenDist
                        closest = p
                    end
                end
            end
        end
        return closest
    end
 
    local function CamLockLoop()
        local run = game:GetService("RunService")
        local cam = workspace.CurrentCamera
        getgenv().CamLockConn = run.RenderStepped:Connect(function()
            if not getgenv().CamLock then
                if getgenv().CamLockConn then getgenv().CamLockConn:Disconnect() getgenv().CamLockConn = nil end
                return
            end
            local target = GetClosestPlayer()
            if target and target.Character and target.Character.Head then
                local headPos = target.Character.Head.Position
                local currentCFrame = cam.CFrame
                local targetCFrame = CFrame.lookAt(currentCFrame.Position, headPos)
                cam.CFrame = currentCFrame:Lerp(targetCFrame, getgenv().Smoothness)
            end
        end)
    end
 
    MainTab:CreateToggle({
        Name = "Enable CamLock",
        CurrentValue = false,
        Flag = "CamLockToggle",
        Callback = function(val)
            getgenv().CamLock = val
            if val then
                task.spawn(CamLockLoop)
            else
                if getgenv().CamLockConn then getgenv().CamLockConn:Disconnect() getgenv().CamLockConn = nil end
            end
        end
    })
 
    MainTab:CreateKeybind({
        Name = "Toggle CamLock Keybind",
        CurrentKeybind = "Q",
        HoldToInteract = false,
        Flag = "CamLockKeybind",
        Callback = function(Keybind)
            getgenv().CamLock = not getgenv().CamLock
            if getgenv().CamLock then
                task.spawn(CamLockLoop)
            else
                if getgenv().CamLockConn then getgenv().CamLockConn:Disconnect() getgenv().CamLockConn = nil end
            end
        end
    })
 
    MainTab:CreateSlider({
        Name = "Smoothness",
        Range = {0.1, 1},
        Increment = 0.05,
        CurrentValue = 0.5,
        Flag = "SmoothnessSlider",
        Callback = function(val)
            getgenv().Smoothness = val
        end
    })
 
    MainTab:CreateSlider({
        Name = "Max Lock Distance",
        Range = {10, 500},
        Increment = 10,
        Suffix = " studs",
        CurrentValue = 100,
        Flag = "MaxLockDistanceSlider",
        Callback = function(val)
            getgenv().MaxLockDistance = val
        end
    })
 
    MainTab:CreateSlider({
        Name = "FOV Radius",
        Range = {50, 1000},
        Increment = 50,
        Suffix = " pixels",
        CurrentValue = 200,
        Flag = "FOVRadiusSlider",
        Callback = function(val)
            getgenv().FOVRadius = val
        end
    })

Rayfield:Notify({
   Title = "Script Executed",
   Content = "User Has Executed Script.",
   Duration = 3.5,
   Image = nil,
})

local HitboxTab = Window:CreateTab("Hitbox Expander", nil) -- Title, Image
local Section = HitboxTab:CreateSection("Hitbox Expander Stuff")
 
    getgenv().HitboxEnabled = false
    getgenv().HitboxSize = 3
 
    local HitboxConnections = {}
    local OriginalHeadSizes = {}
    local HitboxVisuals = {}
 
    local function ClearHitboxes()
        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("Head") then
                local head = player.Character.Head
                if OriginalHeadSizes[player] then
                    head.Size = OriginalHeadSizes[player]
                    OriginalHeadSizes[player] = nil
                end
                if head:FindFirstChild("HitboxVisual") then
                    head.HitboxVisual:Destroy()
                end
            end
        end
        for _, conn in pairs(HitboxConnections) do
            if conn then conn:Disconnect() end
        end
        HitboxConnections = {}
        HitboxVisuals = {}
    end
 
    local function ExpandHitbox(player)
        if player == game.Players.LocalPlayer then return end
        local char = player.Character
        if not char then return end
        local head = char:FindFirstChild("Head")
        if not head then return end
 
        -- Store original size if not already stored
        if not OriginalHeadSizes[player] then
            OriginalHeadSizes[player] = head.Size
        end
 
        -- Expand hitbox
        head.Size = Vector3.new(getgenv().HitboxSize, getgenv().HitboxSize, getgenv().HitboxSize)
 
        -- Visualize hitbox
        if not head:FindFirstChild("HitboxVisual") then
            local visual = Instance.new("SelectionBox")
            visual.Name = "HitboxVisual"
            visual.Adornee = head
            visual.Color3 = Color3.fromRGB(255, 0, 0)
            visual.Transparency = 0.5
            visual.LineThickness = 0.05
            visual.Parent = head
            HitboxVisuals[player] = visual
        else
            HitboxVisuals[player].Transparency = 0.5
        end
    end
 
    local function UpdateHitboxes()
        ClearHitboxes()
        if not getgenv().HitboxEnabled then return end
 
        local Players = game:GetService("Players")
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                ExpandHitbox(player)
            end
        end
 
        -- Handle new players and character respawns
        local connection1 = Players.PlayerAdded:Connect(function(player)
            if getgenv().HitboxEnabled then
                player.CharacterAdded:Connect(function(char)
                    local head = char:WaitForChild("Head", 5)
                    if head and getgenv().HitboxEnabled then
                        ExpandHitbox(player)
                    end
                end)
            end
        end)
 
        local connection2 = game:GetService("RunService").Heartbeat:Connect(function()
            if not getgenv().HitboxEnabled then
                ClearHitboxes()
                connection2:Disconnect()
                return
            end
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
                    ExpandHitbox(player)
                end
            end
        end)
 
        table.insert(HitboxConnections, connection1)
        table.insert(HitboxConnections, connection2)
    end
 
    HitboxTab:CreateToggle({
        Name = "Enable Hitbox Expander",
        CurrentValue = false,
        Flag = "Hitbox",
        Callback = function(val)
            getgenv().HitboxEnabled = val
            if val then
                UpdateHitboxes()
            else
                ClearHitboxes()
            end
        end
    })
 
    HitboxTab:CreateSlider({
        Name = "Hitbox Size",
        Range = {1, 10},
        Increment = 0.5,
        Suffix = " studs",
        CurrentValue = 3,
        Flag = "HitboxSizeSlider",
        Callback = function(Value)
            getgenv().HitboxSize = Value
            if getgenv().HitboxEnabled then
                UpdateHitboxes()
            end
        end
    })

local HitboxTab = Window:CreateTab("Misc", nil) -- Title, Image
local Section = HitboxTab:CreateSection("Misc Stuff")

local Slider = MiscTab:CreateSlider({
   Name = "Walkspeed",
   Range = {0, 300},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.Walkspeed = (Value)
   end,
})

local Slider = MiscTab:CreateSlider({
   Name = "Jump power",
   Range = {0, 300},
   Increment = 1,
   Suffix = "Jump",
   CurrentValue = 16,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
            game.Players.LocalPlayer.Character.Humanoid.Jump = (Value)
   end,
})

local Toggle = MainTab:CreateToggle({
	Name = "Box ESP",
	CurrentValue = false,
	Flag = "Toggle1",
	Callback = function(Value)
		loadstring(game:HttpGet('https://pastebin.com/raw/83qTzr2g'))()
 
	end,
 })

local Toggle = MainTab:CreateToggle({
   Name = "Box ESP",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
            loadstring(game:HttpGet('https://pastebin.com/raw/83qTzr2g'))()
   end,
})
